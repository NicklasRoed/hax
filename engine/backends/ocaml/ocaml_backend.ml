open Hax_engine
open Utils
open Base

include
  Backend.Make
    (struct
      open Features
      include Off
      include On.Slice
      include On.Monadic_binding
      include On.Macro
      include On.Construct_base

      include On.Loop
      include On.For_loop
      include On.State_passing_loop
    end)
    (struct
      let backend = Diagnostics.Backend.Ocaml
    end)

module SubtypeToInputLanguage
    (FA : Features.T
            with type mutable_reference = Features.Off.mutable_reference
             and type continue = Features.Off.continue
             and type break = Features.Off.break
             and type mutable_reference = Features.Off.mutable_reference
             and type mutable_pointer = Features.Off.mutable_pointer
             and type mutable_variable = Features.Off.mutable_variable
             and type reference = Features.Off.reference
             and type raw_pointer = Features.Off.raw_pointer
             and type early_exit = Features.Off.early_exit
             and type question_mark = Features.Off.question_mark
             and type as_pattern = Features.Off.as_pattern
             and type lifetime = Features.Off.lifetime
             and type monadic_action = Features.Off.monadic_action
             and type arbitrary_lhs = Features.Off.arbitrary_lhs
             and type nontrivial_lhs = Features.Off.nontrivial_lhs
             and type block = Features.Off.block
             and type quote = Features.Off.quote
             and type dyn = Features.Off.dyn
             and type match_guard = Features.Off.match_guard
             and type trait_item_default = Features.Off.trait_item_default
             and type unsafe = Features.Off.unsafe
             and type trait_impls = Features.Off.trait_impls
             and type loop = Features.On.loop
             and type for_loop = Features.On.for_loop
             and type while_loop = Features.Off.while_loop
             and type for_index_loop = Features.Off.for_index_loop
             and type state_passing_loop = Features.On.state_passing_loop
             and type fold_like_loop = Features.Off.fold_like_loop
           ) =
struct
  module FB = InputLanguage

  include
    Subtype.Make (FA) (FB)
      (struct
        module A = FA
        module B = FB
        include Features.SUBTYPE.Id
        include Features.SUBTYPE.On.Monadic_binding
        include Features.SUBTYPE.On.Construct_base
        include Features.SUBTYPE.On.Slice
        include Features.SUBTYPE.On.Macro
        include Features.SUBTYPE.On.Loop
        include Features.SUBTYPE.On.For_loop
        include Features.SUBTYPE.On.State_passing_loop
      end)

  let metadata = Phase_utils.Metadata.make (Reject (NotInBackendLang backend))
end

module AST = Ast.Make (InputLanguage)
module BackendOptions = Backend.UnitBackendOptions
open Ast
module OCamlNamePolicy = Concrete_ident.DefaultNamePolicy
module U = Ast_utils.Make (InputLanguage)
module RenderId = Concrete_ident.MakeRenderAPI (OCamlNamePolicy)
open AST

let hardcoded_ocaml_headers =
  "(* File automatically generated by Hacspec *)\n\
   open Stdint"

module BasePrinter = Generic_printer.Make (InputLanguage)

module Make
    (Default : sig
      val default : string -> string
    end)
    (Attrs : Attrs.WITH_ITEMS) =
struct
  open PPrint

  let default_string_for s = "TODO: please implement the method `" ^ s ^ "`"
  let default_document_for = default_string_for >> string

  type ('get_span_data, 'a) object_type =
    ('get_span_data, 'a) BasePrinter.Gen.object_type

  class printer =
    object (self)
      inherit BasePrinter.base

      (* BEGIN GENERATED *)
      method arm ~arm ~span:_ = arm#p

      method arm' ~super:_ ~arm_pat ~body ~guard:_ =
        arm_pat#p ^^ space ^^ string "->" ^^ nest 2 (break 1 ^^ body#p)

      method attrs x1 = default_document_for "attrs"

      method binding_mode_ByRef _x1 _x2 =
        default_document_for "binding_mode_ByRef"

      method binding_mode_ByValue = default_document_for "binding_mode_ByValue"
      method borrow_kind_Mut _x1 = default_document_for "borrow_kind_Mut"
      method borrow_kind_Shared = default_document_for "borrow_kind_Shared"
      method borrow_kind_Unique = default_document_for "borrow_kind_Unique"
      method cf_kind_BreakOnly = default_document_for "cf_kind_BreakOnly"

      method cf_kind_BreakOrReturn =
        default_document_for "cf_kind_BreakOrReturn"

      method common_array x1 = brackets (string "|" ^^ (separate (semi ^^ space) x1) ^^ string "|")

      method dyn_trait_goal ~trait:_ ~non_self_args:_ =
        default_document_for "dyn_trait_goal"

      method error_expr x1 = parens (string x1 ^^ string "(* ERROR EXPR *)")
      method error_item x1 = parens (string x1 ^^ string "(* ERROR ITEM *)")
      method error_pat x1 = parens (string x1 ^^ string "(* ERROR PAT *)")

      method expr ~e ~span:_ ~typ:_ = e#p

      method expr'_AddressOf ~super:_ ~mut:_ ~e:_ ~witness:_ =
        default_document_for "expr'_AddressOf"

      method expr'_App_application ~super:_ ~f ~args ~generics:_ =
        let operators =
          let c = Global_ident.of_name ~value:true in
          [
            (c Rust_primitives__hax__array_of_list, (3, "Array.set")); 
            (c Core__ops__index__Index__index, (2, "Array.get")); 
            (c Core__ops__bit__BitXor__bitxor, (2, "lxor")); 
            (c Core__ops__bit__BitAnd__bitand, (2, "land")); 
            (c Core__ops__bit__BitOr__bitor, (2, "lor")); 
            (c Core__ops__bit__Not__not, (1, "lnot")); 
            (c Core__ops__arith__Add__add, (2, "+")); 
            (c Core__ops__arith__Sub__sub, (2, "-")); 
            (c Core__ops__arith__Mul__mul, (2, "*")); 
            (c Core__ops__arith__Div__div, (2, "/")); 
            (c Core__ops__arith__Rem__rem, (2, "mod")); 
            (c Core__ops__bit__Shl__shl, (2, "lsl")); 
            (c Core__ops__bit__Shr__shr, (2, "lsr"));
            (c Core__cmp__PartialEq__eq, (2, "=")); 
            (c Core__cmp__PartialOrd__lt, (2, "<")); 
            (c Core__cmp__PartialOrd__le, (2, "<="));
            (c Core__cmp__PartialEq__ne, (2, "<>")); 
            (c Core__cmp__PartialOrd__ge, (2, ">="));
            (c Core__cmp__PartialOrd__gt, (2, ">"));
            (`Primitive (LogicalOp And), (2, "&&"));
            (`Primitive (LogicalOp Or), (2, "||"));
            (c Rust_primitives__hax__int__add, (2, "+")); 
            (c Rust_primitives__hax__int__sub, (2, "-")); 
            (c Rust_primitives__hax__int__mul, (2, "*")); 
            (c Rust_primitives__hax__int__div, (2, "/")); 
            (c Rust_primitives__hax__int__rem, (2, "mod")); 
            (c Rust_primitives__hax__int__ge, (2, ">=")); 
            (c Rust_primitives__hax__int__le, (2, "<=")); 
            (c Rust_primitives__hax__int__gt, (2, ">")); 
            (c Rust_primitives__hax__int__lt, (2, "<")); 
            (c Rust_primitives__hax__int__ne, (2, "<>")); 
            (c Rust_primitives__hax__int__eq, (2, "="));
          ]
          |> Map.of_alist_exn (module Global_ident)
        in
        (match f#v with
        | { e = GlobalVar x } when Map.mem operators x ->
          let arity, op = Map.find_exn operators x in
          if List.length args <> arity then
              string "Bad arity for operator application"
          else
            (match arity with
            | 1 ->
              let unary_arg = List.nth_exn args 0 in
              string op ^^ space ^^ parens unary_arg#p
            | 2 ->
              let binary_arg1 = List.nth_exn args 0 in
              let binary_arg2 = List.nth_exn args 1 in
              (match (binary_arg1#v.typ, binary_arg2#v.typ) with
                | (TInt {size; signedness}, _) | (_, TInt {size; signedness}) ->
                  let is_arch = ref false in 
                  let int_size = match size with
                  | SSize -> 
                    is_arch := true;
                    parens binary_arg1#p ^^ space ^^ string op ^^ space ^^ parens binary_arg2#p
                  | S8 ->
                    string "8"
                  | S16 ->
                    string "16"
                  | S32 ->
                    string "32"
                  | S64 ->
                    string "64"
                  | S128 ->
                    string "128"
                in
                let sign = match signedness with
                  | Signed -> 
                    if !is_arch then
                      empty
                    else string "Int"
                  | Unsigned -> 
                    if !is_arch then
                      empty
                    else string "Uint"
                in
                let int_op = match op with
                  | "+" | "-" | "*" | "/" ->
                    string "." ^^ parens (parens binary_arg1#p ^^ space ^^ string op ^^ space ^^ parens binary_arg2#p)
                  | "=" | "<" | "<=" | ">" | ">=" | "<>" ->
                    if !is_arch == false then
                      string ".compare" ^^ space ^^ parens binary_arg1#p ^^ space ^^ parens binary_arg2#p ^^ space ^^
                      string op ^^ space ^^ string "0"
                    else 
                      parens binary_arg1#p ^^ space ^^ string op ^^ space ^^ parens binary_arg2#p
                  | "mod" ->
                    string ".rem" ^^ space ^^ parens binary_arg1#p ^^ parens binary_arg2#p
                  | _ -> string "What"
                  in
                  if !is_arch == true then int_size
                  else sign ^^ int_size ^^ int_op
                | _ ->
                  if String.equal "Array.get" op then
                    string op ^^ space ^^ parens binary_arg1#p ^^ space ^^ parens binary_arg2#p
                  else
                    parens binary_arg1#p ^^ space ^^ string op ^^ space ^^ parens binary_arg2#p) 
            | 3 ->
              string op ^^ concat_map (fun x -> space ^^ parens x#p) args
            )
        | _ -> f#p ^^ concat_map (fun x -> space ^^ parens x#p) args)

      method expr'_App_constant ~super:_ ~constant ~generics:_ =
        constant#p
      
      method expr'_App_field_projection ~super:_ ~field ~e =
       let rendered = RenderId.render field#v in
       e#p ^^ string "." ^^ string rendered.name
      
      (* We experience a problem, where size is always 0. *)
      method expr'_App_tuple_projection ~super ~size ~nth ~e = 
        match (size, nth) with
        | (2, 0) -> string "fst" ^^ space ^^ e#p
        | (2, 1) -> string "snd" ^^ space ^^ e#p
        | (_, _) ->
            string "(match" ^^ space ^^ e#p ^^ space ^^ string "with" ^^ break 1 ^^
            string "|" ^^ space ^^ 
            let pattern = 
              separate (comma ^^ space) (List.init size (fun i -> 
                if i = nth then string "x" else string "_")) 
            in
            parens pattern ^^ space ^^ string "->" ^^ space ^^ string "x" ^^ string ")"

      method expr'_Ascription ~super:_ ~e ~typ =
        e#p ^^ string " : " ^^ typ#p

      method expr'_Assign ~super:_ ~lhs:_ ~e:_ ~witness:_ =
        default_document_for "expr'_Assign"

      method expr'_Block ~super:_ ~e:_ ~safety_mode:_ ~witness:_ =
        default_document_for "expr'_Block"

      method expr'_Borrow ~super:_ ~kind:_ ~e:_ ~witness:_ =
        default_document_for "expr'_Borrow"

      method expr'_Break ~super:_ ~e:_ ~acc:_ ~label:_ ~witness:_ =
        default_document_for "expr'_Break"

      method expr'_Closure ~super:_ ~params ~body ~captures:_ =
        parens (!^"fun"
        ^^ concat_map (fun x -> space ^^ x#p) params
        ^^ space ^^ !^"->" ^^ space
        ^^ nest 2 (break 1 ^^ body#p)) (* Closures are weird *)

      method expr'_Construct_inductive ~super ~constructor ~is_record ~is_struct ~fields ~base =
        let fields_or_empty =
          if List.is_empty fields then empty
          else
            space ^^ parens ((separate_map (comma ^^ space) (fun x -> (snd x)#p) fields))
        in
        if is_record && is_struct then
        (* In OCaml, records use curly braces with field assignments *)
          match base with
            | Some x ->
              let field_or_proj = List.map ~f:(fun x ->
                match x with
                | (hd, _) -> 
                  (match hd#v with
                  | `Projector (`Concrete cident) | `Concrete cident -> string (RenderId.render cident).name
                  | _ -> string "What happened here?")
              ) fields
              in
              braces (space ^^ x#p ^^ space ^^ string "with" ^^ space ^^ separate space field_or_proj ^^ space ^^ equals ^^ fields_or_empty ^^ space)  
            | None -> 
              braces
              (separate_map (semi ^^ space) 
                  (fun (name, value) -> 
                    let concrete_name = match name#v with
                      | `Concrete cid -> string (RenderId.render cid).name ^^ space ^^ equals ^^ space ^^ value#p
                      | _ -> string "Unexpected non-concrete identifier."
                    in concrete_name
                  ) fields)
        else if not is_record then
          constructor#p ^^ fields_or_empty
        else if not is_struct then
          let field_idents = List.map ~f:(fun x ->
            match x with
            | (fst, _) -> fst
            ) fields
          in
          let field_exprs = List.map ~f:(fun x ->
            match x with
            | (_, snd) -> snd
            ) fields
          in
          let fields_docs = 
            match List.map2 ~f:(fun id expr -> id#p ^^ space ^^ equals ^^ space ^^ expr#p) field_idents field_exprs with 
            | Ok result -> 
              constructor#p ^^ space ^^ lbrace ^^ separate (semi ^^ space) result ^^ rbrace
            | Unequal_lengths -> string "Something very unexpected happened."
            in fields_docs
        else
          string "Something very unexpected happened."


      method expr'_Construct_tuple ~super:_ ~components =
        if List.length components == 0 then !^"()"
        else parens (separate_map (comma ^^ space) (fun x -> x#p) components)

      method expr'_Continue ~super:_ ~acc:_ ~label:_ ~witness:_ =
        default_document_for "expr'_Continue"

      method expr'_EffectAction ~super:_ ~action:_ ~argument:_ =
        default_document_for "expr'_EffectAction"

      method expr'_GlobalVar_concrete ~super x2 =
        let x = U.Reducers.collect_concrete_idents#visit_concrete_ident () x2#v in
        let concrete_idents_list = Set.elements x in
        let results = List.map 
          ~f:(fun concrete_id -> (RenderId.render concrete_id).name) concrete_idents_list 
        in
        match results with
        | [] -> empty
        | [single_element] -> string single_element
        | multiple -> string "haha" 
      
      method expr'_GlobalVar_primitive ~super x2 = 
        match x2 with
        | LogicalOp logop ->
          (match super.typ with
          | TArrow (y1, y2) ->
            (match y1 with
            | h :: _ ->
              (match logop with
              | And -> 
                string "&&"
              | Or ->
                parens (self#entrypoint_ty h) ^^ space ^^ string "||" ^^ space ^^ parens (self#entrypoint_ty y2)
              | _ -> string "Unsupported logical operation")
            | _ -> string "This should never happen1")
          | _ -> string "This should never happen2")
        | Deref -> default_document_for "deref"
        | Cast ->
          match super.typ with
          | TArrow (y1, y2) ->
            let y2_is_int = match y2 with
              | TInt {size = SSize; _} -> false
              | TInt _ -> true
              | _ -> false
            in
            match y1 with
            | [TInt {size = SSize; _} as h] -> 
              if y2_is_int == true then
                self#entrypoint_ty y2 ^^ dot ^^ string "of" ^^ underscore ^^ self#entrypoint_ty h
              else
                self#entrypoint_ty y2 ^^ underscore ^^ string "of" ^^ underscore ^^ self#entrypoint_ty h
            | [TInt _ as h] ->
              self#entrypoint_ty h ^^ dot ^^ string "to" ^^ underscore ^^ self#entrypoint_ty y2
            | h :: [] ->
              if y2_is_int == true then
                self#entrypoint_ty y2 ^^ dot ^^ string "of" ^^ underscore ^^ self#entrypoint_ty h
              else 
                self#entrypoint_ty y2 ^^ underscore ^^ string "of" ^^ underscore ^^ self#entrypoint_ty h
            | _ -> string "This should never happen"
          | _ -> string "This should never happen"
        | _ -> string "Unhandled primitive operation"
        
      method expr'_If ~super:_ ~cond ~then_ ~else_ =
        string "if" ^^ space ^^ cond#p ^^ space ^^ string "then"
        ^^ nest 2 (break 1 ^^ then_#p)
        ^^ break 1 ^^ string "else"
        ^^ nest 2 (break 1 ^^ match else_ with Some x -> x#p | None -> string "()")

      method expr'_Let ~super:_ ~monadic:_ ~lhs ~rhs ~body =
        string "let " ^^ lhs#p ^^ string " = " ^^ rhs#p 
        ^^ space ^^ string "in" ^^ break 1 ^^ body#p

      method expr'_Literal ~super:_ x2 = x2#p
      method expr'_LocalVar ~super:_ x2 = x2#p
      
      method expr'_Loop ~super:_ ~body ~kind ~state ~control_flow:_ ~label:_ ~witness:_ =
        let combined = match state with
          | Some state_doc -> state_doc#p ^^ kind#p
          | None -> kind#p
        in
        let ending = 
          match kind#v with
          | UnconditionalLoop | WhileLoop _ | ForIndexLoop _ -> string "done"
          | ForLoop _ -> empty
        in
        combined ^^ body#p ^^ break 1 ^^ ending
        

      method expr'_MacroInvokation ~super:_ ~macro:_ ~args:_ ~witness:_ =
        default_document_for "expr'_MacroInvokation"

      method expr'_Match ~super:_ ~scrutinee ~arms =
        string "match" ^^ space ^^ scrutinee#p ^^ space ^^ string "with"
        ^^ break 1
        ^^ concat_map (fun x -> string "|" ^^ space ^^ x#p ^^ break 1) arms

      method expr'_QuestionMark ~super:_ ~e:_ ~return_typ:_ ~witness:_ =
        default_document_for "expr'_QuestionMark"

      method expr'_Quote ~super:_ _x2 = default_document_for "expr'_Quote"

      method expr'_Return ~super:_ ~e:_ ~witness:_ =
        default_document_for "expr'_Return"

      method field_pat ~field:_ ~pat = pat#p

      method generic_constraint_GCLifetime _x1 _x2 =
        default_document_for "generic_constraint_GCLifetime"

      method generic_constraint_GCProjection _x1 = 
        default_document_for "generic_constraint_GCProjection"

      method generic_constraint_GCType x1 =
        x1#p

      method generic_param ~ident ~span:_ ~attrs:_ ~kind =
        kind#p ^^ string (String.lowercase ident#v.name)

      method generic_param_kind_GPConst ~typ =
        default_document_for "generic_param_kind_GPConst"

      method generic_param_kind_GPLifetime ~witness:_ =
        default_document_for "generic_param_kind_GPLifetime"

      method generic_param_kind_GPType =
        string "'"

      method generic_value_GConst x1 = 
        default_document_for "generic_value_GConst"

      method generic_value_GLifetime ~lt:_ ~witness:_ =
        default_document_for "generic_value_GLifetime"

      method generic_value_GType x1 =
        x1#p

      method generics ~params ~constraints =
        let constraints_doc = List.filter ~f:(
          fun x ->
            match x#v with
            | GCType impl_ident ->
              not (String.equal ((RenderId.render impl_ident.goal.trait).name) "Sized")
            | _ -> true
        ) constraints
        in
        if List.is_empty params then 
          empty
        else
          separate_map space (fun p -> p#p) params ^^ space ^^
          separate_map space (fun p -> parens p#p) constraints_doc
          
      method guard ~guard:_ ~span:_ = default_document_for "guard"

      method guard'_IfLet ~super:_ ~lhs:_ ~rhs:_ ~witness:_ =
        default_document_for "guard'_IfLet"

      method impl_expr ~kind ~goal = 
        kind#p

      method impl_expr_kind_Builtin _x1 =
        default_document_for "impl_expr_kind_Builtin"

      method impl_expr_kind_Concrete _x1 =
        default_document_for "impl_expr_kind_Concrete"

      method impl_expr_kind_Dyn = default_document_for "impl_expr_kind_Dyn"

      method impl_expr_kind_ImplApp ~impl:_ ~args:_ =
        default_document_for "impl_expr_kind_ImplApp"

      method impl_expr_kind_LocalBound ~id =
        string id

      method impl_expr_kind_Parent ~impl:_ ~ident:_ =
        default_document_for "impl_expr_kind_Parent"

      method impl_expr_kind_Projection ~impl:_ ~item:_ ~ident:_ =
        default_document_for "impl_expr_kind_Projection"

      method impl_expr_kind_Self = default_document_for "impl_expr_kind_Self"

      method impl_ident ~goal ~name = 
        goal#p

      method impl_item ~ii_span:_ ~ii_generics:_ ~ii_v:_ ~ii_ident:_ ~ii_attrs:_ = (* NOT YET SEEN *)
        default_document_for "impl_item"

      method impl_item'_IIFn ~body:_ ~params:_ = (* NOT YET SEEN *)
        default_document_for "impl_item'_IIFn"

      method impl_item'_IIType ~typ ~parent_bounds:_ = (* NOT YET SEEN *)
        typ#p

      method item ~v ~span:_ ~ident:_ ~attrs:_ = v#p ^^ break 1

      method item'_Alias ~super:_ ~name:_ ~item:_ = (* NOT YET SEEN *)
        default_document_for "item'_Alias"

      method item'_Enum_Variant ~name ~arguments ~is_record ~attrs:_ =
        let record_types = List.map ~f:(fun x ->
          match x with
          | (_, snd, _) -> snd
          ) arguments
        in
        if is_record then
          let record_idents = List.map ~f:(fun x ->
            match x with
            | (fst, _, _) -> fst
            ) arguments
          in
          let rec_vars = 
            match List.map2 ~f:(fun id typ -> id#p ^^ string ":" ^^ space ^^ typ#p) record_idents record_types with 
            | Ok result -> 
              name#p ^^ space ^^ string "of" ^^ space ^^ lbrace ^^ separate (semi ^^ space) result ^^ rbrace
            | Unequal_lengths -> string "GGS"
            in
            rec_vars
          else
            let no_types_given = List.is_empty record_types in
            if no_types_given then
              name#p
            else 
              name#p ^^ space ^^ string "of" ^^ space ^^ separate_map (space ^^ star ^^ space) (fun x -> x#p) record_types

      method item'_Fn ~super ~name ~generics ~body ~params ~safety:_ =
        let is_rec =
          Set.mem
            (U.Reducers.collect_concrete_idents#visit_expr () body#v)
            name#v
        in
        let rec_header = 
          if is_rec then string "rec" ^^ space else empty
        in
        let _, g_params, g_constraints = generics#v in
        let typ =
          self#_do_not_override_lazy_of_ty AstPos_item'_Fn_body body#v.typ
        in
        let header = 
          string "let" ^^ space ^^ rec_header ^^ name#p ^^ space ^^ separate_map space (fun x -> x#p) params
          ^^ space ^^ colon ^^ space ^^ typ#p ^^ space ^^ equals
        in
        header ^^ nest 2 (break 1 ^^ body#p)
    
      method item'_HaxError ~super:_ _x2 = default_document_for "item'_HaxError"

      method item'_IMacroInvokation ~super:_ ~macro:_ ~argument:_ ~span:_
          ~witness:_ =
        default_document_for "item'_IMacroInvokation"

      method item'_Impl ~super:_ ~generics ~self_ty ~of_trait ~items ~parent_bounds:_ ~safety:_ ~witness:_ =
        let _, params, constraints = generics#v in
        let trait_tuple = of_trait#v in
        let trait_name = fst trait_tuple in
        let fix_self_ty = 
          match self_ty#v with
          | TInt x -> string (show_int_kind x)
          | _ -> self_ty#p
        in
        let fn_name_prefix_str = string (RenderId.render trait_name#v).name ^^ underscore ^^ fix_self_ty in
        let lowercase_trait_args trait_arg =
          match trait_arg#v with
          | GType (TApp { ident = `Concrete con_ident; args }) ->
            let con_ident_name_str = (RenderId.render con_ident).name in
            string (String.lowercase con_ident_name_str)
          | GType x -> (self#_do_not_override_lazy_of_ty AstPos_param__typ x)#p
        in
        let trait_args = List.map (snd trait_tuple) ~f:lowercase_trait_args
        in
        let item_to_doc item =
          match item#v with
          | { ii_v = IIFn {body; params}; ii_ident; _ } ->
            string "let" ^^ space ^^ fn_name_prefix_str ^^ underscore ^^ string ((RenderId.render ii_ident).name)
            ^^ space ^^ separate_map space (fun x -> (self#_do_not_override_lazy_of_param AstPos_param__typ x)#p) params ^^ space ^^ colon
            ^^ space ^^ (self#_do_not_override_lazy_of_ty AstPos_expr__e body.typ)#p ^^ space ^^ equals ^^
            nest 2 (break 1 ^^ (self#_do_not_override_lazy_of_expr AstPos_expr__e body)#p)
          | _ -> empty

        in
        let items_doc = List.map items ~f:item_to_doc
        in
        separate ((break 1) ^^ (break 1)) items_doc

      method item'_NotImplementedYet =
        string "(* Not Implemented Yet *)"

      method item'_Quote ~super:_ ~quote:_ ~origin:_ =
        default_document_for "item'_Quote"

      method item'_Trait ~super:_ ~name ~generics ~items ~safety:_ = 
        empty

      method item'_TyAlias ~super:_ ~name:_ ~generics:_ ~ty:_ = (* NOT YET SEEN *)
        default_document_for "item'_TyAlias"

      method item'_Type_enum ~super:_ ~name ~generics ~variants =
        let type_params = List.filter_map generics#v.params
          ~f:(fun p ->
              match p.kind with
              | GPType -> Some (String.lowercase p.ident.name)
              | _ -> None
          )
        in          
        let type_params_doc = 
          if List.is_empty type_params then
            empty
          else if List.length type_params = 1 then
            string ("'" ^ (List.hd_exn type_params) ^ " ")
          else
            string "(" ^^ 
            separate_map comma (fun name -> string ("'" ^ name)) type_params ^^ 
            string ") "
          in
          let enum_name = (RenderId.render name#v).name in
          string "type " ^^ type_params_doc ^^ string enum_name ^^ space ^^ equals ^^
          nest 2 (break 1 ^^ string "|" ^^ space ^^ 
                  separate_map (break 1 ^^ string "|" ^^ space) (fun v -> v#p) variants)

      method item'_Type_struct ~super:_ ~name ~generics ~tuple_struct ~arguments =
        let type_params = List.filter_map generics#v.params
          ~f:(fun p ->
              match p.kind with
              | GPType -> Some (String.lowercase p.ident.name)
              | _ -> None
          )
        in                  
        let translate_type typ =
          match typ#v with
          | TParam ident ->
            let param_name = String.lowercase ident.name in
            if List.mem ~equal:String.equal type_params param_name then
              string ("'" ^ param_name)
            else
              typ#p
          | _ -> 
            typ#p
        in                  
        let types = List.map 
          ~f:(fun x ->
                let snd_elem = match x with
                | (_, s, _) -> translate_type s
                in snd_elem
              ) arguments
        in                  
        let trimmed_var_name_str = (RenderId.render name#v).name
        in
        let trimmed_name_str =
          String.sub trimmed_var_name_str 2 (String.length trimmed_var_name_str - 2)
        in
        let trimmed_name = string trimmed_name_str in
        let trimmed_var_name = string (String.lowercase trimmed_var_name_str) in                  
        let type_params_doc = 
          if List.is_empty type_params then
            empty
          else if List.length type_params = 1 then
            string ("'" ^ (List.hd_exn type_params) ^ " ")
          else
            string "(" ^^ 
            separate_map comma (fun name -> string ("'" ^ name)) type_params ^^ 
            string ") "
        in        
        match tuple_struct with
        | true ->
          let type_tuple_struct = if List.is_empty types then string "()"
          else parens (separate (space ^^ star ^^ space) types)
          in
          string "type " ^^ type_params_doc ^^ trimmed_var_name ^^ space ^^ equals ^^ space
          ^^ trimmed_name ^^ space ^^ string "of" ^^ space ^^ type_tuple_struct
        | false ->
          let idents = List.map 
            ~f:(fun x -> 
              let first_elem = match x with
                | (f, _, _) ->  string ((RenderId.render f#v).name)
              in first_elem
            ) arguments
          in
          let field_definitions = 
            match List.map2 ~f:(fun id typ -> nest 2 (break 1 ^^ id ^^ string ": " ^^ typ ^^ semi)) idents types with
            | Ok result -> 
              string "type " ^^ type_params_doc ^^ trimmed_var_name ^^ space ^^ equals ^^ space ^^ lbrace ^^
              concat result ^^ break 1 ^^ rbrace
            | Unequal_lengths -> string "GG"
          in 
          field_definitions
            
      method item'_Use ~super:_ ~path ~is_external ~rename:_ =
        if List.length path = 0 || is_external then empty
        else
          let module_name =
            match path with
            | "crate" :: xs -> 
                String.capitalize (Option.value ~default:"Crate" 
                  (Option.bind current_namespace ~f:List.hd)) ^
                (if List.length xs > 0 then "." else "") ^
                String.concat ~sep:"." (List.map ~f:String.capitalize xs)
            | "super" :: xs ->
                let parent_namespace = 
                  Option.value ~default:[] 
                    (Option.bind current_namespace ~f:List.tl)
                in
                String.concat ~sep:"." (List.map ~f:String.capitalize 
                  ((List.drop_last_exn parent_namespace) @ xs))
            | [ a ] -> 
                String.capitalize a
            | xs -> 
                String.concat ~sep:"." (List.map ~f:String.capitalize xs)
          in
          if String.is_empty module_name then empty
          else
            string "open" ^^ space ^^ string module_name

      method item_quote_origin ~item_kind:_ ~item_ident:_ ~position:_ =
        default_document_for "item_quote_origin"

      method lhs_LhsArbitraryExpr ~e:_ ~witness:_ =
        default_document_for "lhs_LhsArbitraryExpr"

      method lhs_LhsArrayAccessor ~e:_ ~typ:_ ~index:_ ~witness:_ =
        default_document_for "lhs_LhsArrayAccessor"

      method lhs_LhsFieldAccessor_field ~e:_ ~typ:_ ~field:_ ~witness:_ =
        default_document_for "lhs_LhsFieldAccessor_field"

      method lhs_LhsFieldAccessor_tuple ~e:_ ~typ:_ ~nth:_ ~size:_ ~witness:_ =
        default_document_for "lhs_LhsFieldAccessor_tuple"

      method lhs_LhsLocalVar ~var:_ ~typ:_ =
        default_document_for "lhs_LhsLocalVar"

      method literal_Bool x1 = string (Bool.to_string x1)
      method literal_Char x1 = string "'" ^^ string (Char.to_string x1) ^^ string "'"

      method literal_Float ~value ~negative ~kind:_ =
        (if negative then !^"-" else empty) ^^ string value

      method literal_Int ~value ~negative ~kind =
        match kind with
        | { size; signedness } ->
          let arch_size = size == SSize in
          let size_doc = match size with
            | S8 -> string "8"
            | S16 -> string "16"
            | S32 -> string "32"
            | S64 -> string "64"
            | S128 -> string "128"
            | SSize -> empty
          in
          let sign_doc = match signedness with
            | Unsigned -> 
              if arch_size then
                empty
              else string "Uint"
            | Signed -> 
              if arch_size then
                empty
              else string "Int"
          in
          let suffix_doc =
            if arch_size then
              empty
            else string ".of_int" ^^ space
          in
        sign_doc ^^ size_doc ^^ suffix_doc ^^ (if negative then parens (!^"-" ^^ string value) else string value) 

      method literal_String x1 = string "\"" ^^ string x1 ^^ string "\""

      method loop_kind_ForIndexLoop ~start ~end_ ~var ~var_typ:_ ~witness:_ =
        string "for" ^^ space ^^ var#p ^^ space ^^ string "=" ^^ space ^^ 
        start#p ^^ space ^^ string "to" ^^ space ^^ end_#p ^^ space ^^ string "do" ^^ break 1

      method loop_kind_ForLoop ~pat ~it ~witness:_ =
        string "Seq.iter" ^^ space ^^ 
        string "(fun" ^^ space ^^ pat#p ^^ space ^^ string "->" ^^ break 1 ^^
        string ")" ^^ space ^^ it#p

      method loop_kind_UnconditionalLoop =
        string "while true do" ^^ break 1

      method loop_kind_WhileLoop ~condition ~witness:_ =
        string "while" ^^ space ^^ condition#p ^^ space ^^ string "do" ^^ break 1

      method loop_state ~init ~bpat ~witness:_ = 
        let init_doc = init#p in
        let pat_doc = bpat#p in
        string "let mutable" ^^ space ^^ pat_doc ^^ space ^^ equals ^^ 
        space ^^ init_doc ^^ space ^^ string "in" ^^ break 1

      method modul x1 = separate_map (break 1) (fun x -> x#p) x1

      method param ~pat ~typ ~typ_span:_ ~attrs:_ =
        match typ#v with
        | TApp { ident = `Concrete con_ident; args } ->
          let con_ident_name_str = (RenderId.render con_ident).name in
          parens (pat#p ^^ string ":" ^^ space ^^ string (String.lowercase con_ident_name_str))
        | _ -> parens (pat#p ^^ string ": " ^^ typ#p)
        

      method pat ~p ~span:_ ~typ = p#p

      method pat'_PAscription ~super:_ ~typ ~typ_span:_ ~pat =
        pat#p ^^ string " : " ^^ typ#p

      method pat'_PBinding ~super:_ ~mut:_ ~mode:_ ~var ~typ:_ ~subpat:_ =
        var#p

      method pat'_PConstant ~super:_ ~lit =
        lit#p

      method pat'_PConstruct_inductive ~super ~constructor ~is_record 
          ~is_struct ~fields =
        let constructor_doc = constructor#p
        in          
        if List.length fields = 0 then
          constructor_doc
        else if is_record then
          constructor_doc ^^ space ^^ 
          string "{" ^^ 
          separate_map (string ";" ^^ space) 
            (fun (field, pat) -> field#p ^^ space ^^ equals ^^ space ^^ pat#p)
            fields ^^ 
          string "}"
        else
          constructor_doc ^^ space ^^ 
          string "(" ^^ 
          separate_map (string "," ^^ space) 
            (fun (_, pat) -> pat#p)
            fields ^^ 
          string ")"

      method pat'_PConstruct_tuple ~super:_ ~components =
        parens (separate_map (comma ^^ space) (fun x -> x#p) components)

      method pat'_PDeref ~super:_ ~subpat:_ ~witness:_ =
        default_document_for "pat'_PDeref"

      method pat'_PWild = string "_"
      method printer_name = default_string_for "OCaml printer"

      method projection_predicate ~impl:_ ~assoc_item:_ ~typ:_ = (* NOT YET SEEN *)
        default_document_for "projection_predicate"

      method safety_kind_Safe = default_document_for "safety_kind_Safe"
      method safety_kind_Unsafe _x1 = default_document_for "safety_kind_Unsafe"

      method supported_monads_MException _x1 =
        default_document_for "supported_monads_MException"

      method supported_monads_MOption =
        default_document_for "supported_monads_MOption"

      method supported_monads_MResult _x1 =
        default_document_for "supported_monads_MResult"
      
      method trait_goal ~trait ~args =
        separate_map space (fun x -> x#p) args ^^ space ^^ colon ^^ space ^^ trait#p

      method trait_item ~ti_span ~ti_generics ~ti_v ~ti_ident ~ti_attrs = 
        empty

      method trait_item'_TIDefault ~params:_ ~body:_ ~witness:_ =
        default_document_for "trait_item'_TIDefault"

      method trait_item'_TIFn x1 = 
        x1#p

      method trait_item'_TIType x1 =
        separate_map space (fun x -> x#p) x1

      method ty_TApp_application ~typ ~generics =
       typ#p ^^ concat_map (fun x -> space ^^ parens x#p) generics

      method ty_TApp_tuple ~types = 
        if List.length types == 0 then string "unit"
        else parens (separate_map (space ^^ star ^^ space) (fun x -> self#entrypoint_ty x) types)

      method ty_TArray ~typ ~length:_ = typ#p ^^ space ^^ string "array" 
      method ty_TArrow x1 x2 = 
        concat_map (fun x -> x#p ^^ space ^^ string "->" ^^ space) x1 ^^ x2#p

      method ty_TAssociatedType ~impl:_ ~item = (* NOT YET SEEN *)
        item#p

      method ty_TBool = string "bool"
      method ty_TChar = string "char"
      method ty_TDyn ~witness:_ ~goals:_ = default_document_for "ty_TDyn"
      method ty_TFloat _x1 = string "float"
      method ty_TInt x1 = 
        match x1 with
        | { size; signedness } -> 
          if size == SSize then
            string "int"
          else   
            (
              (match signedness with
              | Unsigned -> string "Uint"
              | Signed -> string "Int")
              ^^
              match size with
              | S8 -> string "8"
              | S16 -> string "16"
              | S32 -> string "32"
              | S64 -> string "64"
              | S128 -> string "128"
              | _ -> empty)
          ^^ string ".t"
      method ty_TOpaque x1 = x1#p
      method ty_TParam x1 = 
        let name = x1#v.name in
        if String.equal (String.lowercase name) "self" then
          string ("'" ^ String.lowercase name)
        else
          string (String.lowercase name)

      method ty_TRawPointer ~witness:_ = default_document_for "ty_TRawPointer"

      method ty_TRef ~witness:_ ~region:_ ~typ:_ ~mut:_ =
        default_document_for "ty_TRef"

      method ty_TSlice ~witness:_ ~ty = ty#p ^^ space ^^ string "array" (* PLACEHOLDER FOR ACTUAL SLICES (BORROW FEATURE?)*)
      method ty_TStr = string "string"
      (* END GENERATED *)
    end

    let new_printer : BasePrinter.finalized_printer =
      BasePrinter.finalize (fun () -> (new printer :> BasePrinter.printer))
  end
  
  module type S = sig
    val new_printer : BasePrinter.finalized_printer
  end
  
  let make (module M : Attrs.WITH_ITEMS) =
    let open (
      Make
        (struct
          let default x = x
        end)
        (M) :
        S) in
    new_printer
  
  let translate m _ ~bundles:_ (items : AST.item list) : Types.file list =
    let my_printer = make m in
    U.group_items_by_namespace items
    |> Map.to_alist
    |> List.filter_map ~f:(fun (_, items) ->
           let* first_item = List.hd items in
           Some ((RenderId.render first_item.ident).path, items))
    |> List.map ~f:(fun (ns, items) ->
           let mod_name =
             String.concat ~sep:"_"
               (List.map ~f:(map_first_letter String.uppercase) ns)
           in
           let sourcemap, contents =
             let annotated = my_printer#entrypoint_modul items in
             let open Generic_printer.AnnotatedString in
             let header = pure (hardcoded_ocaml_headers ^ "\n") in
             let annotated = concat header annotated in
             (to_sourcemap annotated, to_string annotated)
           in
           let sourcemap = Some sourcemap in
           let path = mod_name ^ ".ml" in
           Types.{ path; contents; sourcemap })
  
  open Phase_utils
  
  module TransformToInputLanguage =
    [%functor_application
    Phases.Reject.Unsafe(Features.Rust)
    |> Phases.Reject.RawOrMutPointer
    |> Phases.And_mut_defsite
    |> Phases.Reconstruct_asserts
    |> Phases.Reconstruct_for_loops
    |> Phases.Direct_and_mut
    |> Phases.Reject.Arbitrary_lhs
    |> Phases.Drop_blocks
    |> Phases.Drop_match_guards
    |> Phases.Reject.Continue
    |> Phases.Drop_references
    |> Phases.Trivialize_assign_lhs
    |> Phases.Reconstruct_question_marks
    (* |> Side_effect_utils.Hoist *)
    |> Phases.Monomorphize
    |> Phases.Local_mutation (**)
    |> Phases.Reject.Continue
    |> Phases.Cf_into_monads
    |> Phases.Reject.EarlyExit
    (* |> Phases.Functionalize_loops *)
    |> Phases.Reject.As_pattern
    |> Phases.Reject.Dyn
    |> Phases.Reject.Trait_item_default
    (* |> Phases.Bundle_cycles *)(**)
    |> Phases.Sort_items
    |> SubtypeToInputLanguage
    |> Identity
    ]
    [@ocamlformat "disable"] 
  
  
  let apply_phases (_bo : BackendOptions.t) (items : Ast.Rust.item list) :
      AST.item list =
    TransformToInputLanguage.ditems items
  